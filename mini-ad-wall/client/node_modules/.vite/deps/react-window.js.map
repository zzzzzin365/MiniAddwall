{
  "version": 3,
  "sources": ["../../react-window/lib/utils/isRtl.ts", "../../react-window/lib/core/useIsRtl.ts", "../../react-window/lib/hooks/useIsomorphicLayoutEffect.ts", "../../react-window/lib/utils/parseNumericStyleValue.ts", "../../react-window/lib/hooks/useResizeObserver.ts", "../../react-window/lib/hooks/useStableCallback.ts", "../../react-window/lib/utils/getRTLOffsetType.ts", "../../react-window/lib/utils/adjustScrollOffsetForRtl.ts", "../../react-window/lib/utils/assert.ts", "../../react-window/lib/utils/shallowCompare.ts", "../../react-window/lib/core/getEstimatedSize.ts", "../../react-window/lib/core/getOffsetForIndex.ts", "../../react-window/lib/core/getStartStopIndices.ts", "../../react-window/lib/core/createCachedBounds.ts", "../../react-window/lib/core/useCachedBounds.ts", "../../react-window/lib/core/useItemSize.ts", "../../react-window/lib/core/useVirtualizer.ts", "../../react-window/lib/hooks/useMemoizedObject.ts", "../../react-window/lib/utils/arePropsEqual.ts", "../../react-window/lib/components/grid/Grid.tsx", "../../react-window/lib/components/grid/useGridCallbackRef.ts", "../../react-window/lib/components/grid/useGridRef.ts", "../../react-window/lib/components/list/isDynamicRowHeight.ts", "../../react-window/lib/components/list/List.tsx", "../../react-window/lib/components/list/useDynamicRowHeight.ts", "../../react-window/lib/components/list/useListCallbackRef.ts", "../../react-window/lib/components/list/useListRef.ts", "../../react-window/lib/utils/getScrollbarSize.ts"],
  "sourcesContent": ["export function isRtl(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n  while (currentElement) {\n    if (currentElement.dir) {\n      return currentElement.dir === \"rtl\";\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return false;\n}\n", "import { useLayoutEffect, useState, type HTMLAttributes } from \"react\";\nimport { isRtl } from \"../utils/isRtl\";\n\nexport function useIsRtl(\n  element: HTMLElement | null,\n  dir: HTMLAttributes<HTMLElement>[\"dir\"]\n) {\n  const [value, setValue] = useState(dir === \"rtl\");\n\n  useLayoutEffect(() => {\n    if (element) {\n      if (!dir) {\n        setValue(isRtl(element));\n      }\n    }\n  }, [dir, element]);\n\n  return value;\n}\n", "import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n", "import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n", "import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style: CSSProperties | undefined;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n", "import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call during render.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n", "export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n", "import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n", "export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n", "import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n", "import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  if (index < 0 || index >= itemCount) {\n    throw RangeError(`Invalid index specified: ${index}`, {\n      cause: `Index ${index} is not within the range of 0 - ${itemCount - 1}`\n    });\n  }\n\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n", "import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): {\n  startIndexVisible: number;\n  stopIndexVisible: number;\n  startIndexOverscan: number;\n  stopIndexOverscan: number;\n} {\n  const maxIndex = itemCount - 1;\n\n  let startIndexVisible = 0;\n  let stopIndexVisible = -1;\n  let startIndexOverscan = 0;\n  let stopIndexOverscan = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndexVisible = currentIndex;\n  startIndexOverscan = Math.max(0, startIndexVisible - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndexVisible = Math.min(maxIndex, currentIndex);\n  stopIndexOverscan = Math.min(itemCount - 1, stopIndexVisible + overscanCount);\n\n  if (startIndexVisible < 0) {\n    startIndexVisible = 0;\n    stopIndexVisible = -1;\n    startIndexOverscan = 0;\n    stopIndexOverscan = -1;\n  }\n\n  return {\n    startIndexVisible,\n    stopIndexVisible,\n    startIndexOverscan,\n    stopIndexOverscan\n  };\n}\n", "import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n", "import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n", "import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n", "import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { shallowCompare } from \"../utils/shallowCompare\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const [indices, setIndices] = useState<{\n    startIndexVisible: number;\n    stopIndexVisible: number;\n    startIndexOverscan: number;\n    stopIndexOverscan: number;\n  }>({\n    startIndexVisible: 0,\n    startIndexOverscan: 0,\n    stopIndexVisible: -1,\n    stopIndexOverscan: -1\n  });\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const {\n    startIndexVisible,\n    startIndexOverscan,\n    stopIndexVisible,\n    stopIndexOverscan\n  } = {\n    startIndexVisible: Math.min(itemCount - 1, indices.startIndexVisible),\n    startIndexOverscan: Math.min(itemCount - 1, indices.startIndexOverscan),\n    stopIndexVisible: Math.min(itemCount - 1, indices.stopIndexVisible),\n    stopIndexOverscan: Math.min(itemCount - 1, indices.stopIndexOverscan)\n  };\n\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (shallowCompare(next, prev)) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo !== \"function\") {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (!shallowCompare(indices, next)) {\n            setIndices(next);\n          }\n        }\n\n        return scrollOffset;\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  };\n}\n", "import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n", "import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { ariaAttributes: object; style: CSSProperties },\n  nextProps: { ariaAttributes: object; style: CSSProperties }\n): boolean {\n  const {\n    ariaAttributes: prevAriaAttributes,\n    style: prevStyle,\n    ...prevRest\n  } = prevProps;\n  const {\n    ariaAttributes: nextAriaAttributes,\n    style: nextStyle,\n    ...nextRest\n  } = nextProps;\n\n  return (\n    shallowCompare(prevAriaAttributes, nextAriaAttributes) &&\n    shallowCompare(prevStyle, nextStyle) &&\n    shallowCompare(prevRest, nextRest)\n  );\n}\n", "import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode\n} from \"react\";\nimport { useIsRtl } from \"../../core/useIsRtl\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { GridProps } from \"./types\";\n\nexport function Grid<\n  CellProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  cellComponent: CellComponentProp,\n  cellProps: cellPropsUnstable,\n  children,\n  className,\n  columnCount,\n  columnWidth,\n  defaultHeight = 0,\n  defaultWidth = 0,\n  dir,\n  gridRef,\n  onCellsRendered,\n  onResize,\n  overscanCount = 3,\n  rowCount,\n  rowHeight,\n  style,\n  tagName = \"div\" as TagName,\n  ...rest\n}: GridProps<CellProps, TagName>): ReactElement {\n  const cellProps = useMemoizedObject(cellPropsUnstable);\n  const CellComponent = useMemo(\n    () => memo(CellComponentProp, arePropsEqual),\n    [CellComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isRtl = useIsRtl(element, dir);\n\n  const {\n    getCellBounds: getColumnBounds,\n    getEstimatedSize: getEstimatedWidth,\n    startIndexOverscan: columnStartIndexOverscan,\n    startIndexVisible: columnStartIndexVisible,\n    scrollToIndex: scrollToColumnIndex,\n    stopIndexOverscan: columnStopIndexOverscan,\n    stopIndexVisible: columnStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultWidth,\n    direction: \"horizontal\",\n    isRtl,\n    itemCount: columnCount,\n    itemProps: cellProps,\n    itemSize: columnWidth,\n    onResize,\n    overscanCount\n  });\n\n  const {\n    getCellBounds: getRowBounds,\n    getEstimatedSize: getEstimatedHeight,\n    startIndexOverscan: rowStartIndexOverscan,\n    startIndexVisible: rowStartIndexVisible,\n    scrollToIndex: scrollToRowIndex,\n    stopIndexOverscan: rowStopIndexOverscan,\n    stopIndexVisible: rowStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: cellProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    gridRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToCell({\n        behavior = \"auto\",\n        columnAlign = \"auto\",\n        columnIndex,\n        rowAlign = \"auto\",\n        rowIndex\n      }: {\n        behavior?: ScrollBehavior;\n        columnAlign?: Align;\n        columnIndex: number;\n        rowAlign?: Align;\n        rowIndex: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align: columnAlign,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index: columnIndex\n        });\n        const top = scrollToRowIndex({\n          align: rowAlign,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index: rowIndex\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left,\n            top\n          });\n        }\n      },\n\n      scrollToColumn({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left\n          });\n        }\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToRowIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToColumnIndex, scrollToRowIndex]\n  );\n\n  useEffect(() => {\n    if (\n      columnStartIndexOverscan >= 0 &&\n      columnStopIndexOverscan >= 0 &&\n      rowStartIndexOverscan >= 0 &&\n      rowStopIndexOverscan >= 0 &&\n      onCellsRendered\n    ) {\n      onCellsRendered(\n        {\n          columnStartIndex: columnStartIndexVisible,\n          columnStopIndex: columnStopIndexVisible,\n          rowStartIndex: rowStartIndexVisible,\n          rowStopIndex: rowStopIndexVisible\n        },\n        {\n          columnStartIndex: columnStartIndexOverscan,\n          columnStopIndex: columnStopIndexOverscan,\n          rowStartIndex: rowStartIndexOverscan,\n          rowStopIndex: rowStopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onCellsRendered,\n    columnStartIndexOverscan,\n    columnStartIndexVisible,\n    columnStopIndexOverscan,\n    columnStopIndexVisible,\n    rowStartIndexOverscan,\n    rowStartIndexVisible,\n    rowStopIndexOverscan,\n    rowStopIndexVisible\n  ]);\n\n  const cells = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (columnCount > 0 && rowCount > 0) {\n      for (\n        let rowIndex = rowStartIndexOverscan;\n        rowIndex <= rowStopIndexOverscan;\n        rowIndex++\n      ) {\n        const rowBounds = getRowBounds(rowIndex);\n\n        const columns: ReactNode[] = [];\n\n        for (\n          let columnIndex = columnStartIndexOverscan;\n          columnIndex <= columnStopIndexOverscan;\n          columnIndex++\n        ) {\n          const columnBounds = getColumnBounds(columnIndex);\n\n          columns.push(\n            <CellComponent\n              {...(cellProps as CellProps)}\n              ariaAttributes={{\n                \"aria-colindex\": columnIndex + 1,\n                role: \"gridcell\"\n              }}\n              columnIndex={columnIndex}\n              key={columnIndex}\n              rowIndex={rowIndex}\n              style={{\n                position: \"absolute\",\n                left: isRtl ? undefined : 0,\n                right: isRtl ? 0 : undefined,\n                transform: `translate(${isRtl ? -columnBounds.scrollOffset : columnBounds.scrollOffset}px, ${rowBounds.scrollOffset}px)`,\n                height: rowBounds.size,\n                width: columnBounds.size\n              }}\n            />\n          );\n        }\n\n        children.push(\n          <div key={rowIndex} role=\"row\" aria-rowindex={rowIndex + 1}>\n            {columns}\n          </div>\n        );\n      }\n    }\n    return children;\n  }, [\n    CellComponent,\n    cellProps,\n    columnCount,\n    columnStartIndexOverscan,\n    columnStopIndexOverscan,\n    getColumnBounds,\n    getRowBounds,\n    isRtl,\n    rowCount,\n    rowStartIndexOverscan,\n    rowStopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedHeight(),\n        width: getEstimatedWidth(),\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      \"aria-colcount\": columnCount,\n      \"aria-rowcount\": rowCount,\n      role: \"grid\",\n      ...rest,\n      className,\n      dir,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n        maxHeight: \"100%\",\n        maxWidth: \"100%\",\n        flexGrow: 1,\n        overflow: \"auto\",\n        ...style\n      }\n    },\n    cells,\n    children,\n    sizingElement\n  );\n}\n", "import { useState } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Grid component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useGridCallbackRef =\n  useState as typeof useState<GridImperativeAPI | null>;\n", "import { useRef } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Grid component.\n */\nexport const useGridRef = useRef as typeof useRef<GridImperativeAPI>;\n", "import type { DynamicRowHeight } from \"./types\";\n\nexport function isDynamicRowHeight(value: unknown): value is DynamicRowHeight {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    \"getAverageRowHeight\" in value &&\n    typeof value.getAverageRowHeight === \"function\"\n  );\n}\n", "import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode\n} from \"react\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport { isDynamicRowHeight as isDynamicRowHeightUtil } from \"./isDynamicRowHeight\";\nimport type { ListProps } from \"./types\";\n\nexport const DATA_ATTRIBUTE_LIST_INDEX = \"data-react-window-index\";\n\nexport function List<\n  RowProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  children,\n  className,\n  defaultHeight = 0,\n  listRef,\n  onResize,\n  onRowsRendered,\n  overscanCount = 3,\n  rowComponent: RowComponentProp,\n  rowCount,\n  rowHeight: rowHeightProp,\n  rowProps: rowPropsUnstable,\n  tagName = \"div\" as TagName,\n  style,\n  ...rest\n}: ListProps<RowProps, TagName>): ReactElement {\n  const rowProps = useMemoizedObject(rowPropsUnstable);\n  const RowComponent = useMemo(\n    () => memo(RowComponentProp, arePropsEqual),\n    [RowComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isDynamicRowHeight = isDynamicRowHeightUtil(rowHeightProp);\n\n  const rowHeight = useMemo(() => {\n    if (isDynamicRowHeight) {\n      return (index: number) => {\n        return (\n          rowHeightProp.getRowHeight(index) ??\n          rowHeightProp.getAverageRowHeight()\n        );\n      };\n    }\n\n    return rowHeightProp;\n  }, [isDynamicRowHeight, rowHeightProp]);\n\n  const {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: rowProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    listRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToIndex]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const rows = Array.from(element.children).filter((item, index) => {\n      if (item.hasAttribute(\"aria-hidden\")) {\n        // Ignore sizing element\n        return false;\n      }\n\n      const attribute = `${startIndexOverscan + index}`;\n      item.setAttribute(DATA_ATTRIBUTE_LIST_INDEX, attribute);\n\n      return true;\n    });\n\n    if (isDynamicRowHeight) {\n      return rowHeightProp.observeRowElements(rows);\n    }\n  }, [\n    element,\n    isDynamicRowHeight,\n    rowHeightProp,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  useEffect(() => {\n    if (startIndexOverscan >= 0 && stopIndexOverscan >= 0 && onRowsRendered) {\n      onRowsRendered(\n        {\n          startIndex: startIndexVisible,\n          stopIndex: stopIndexVisible\n        },\n        {\n          startIndex: startIndexOverscan,\n          stopIndex: stopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onRowsRendered,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  ]);\n\n  const rows = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (rowCount > 0) {\n      for (\n        let index = startIndexOverscan;\n        index <= stopIndexOverscan;\n        index++\n      ) {\n        const bounds = getCellBounds(index);\n\n        children.push(\n          <RowComponent\n            {...(rowProps as RowProps)}\n            ariaAttributes={{\n              \"aria-posinset\": index + 1,\n              \"aria-setsize\": rowCount,\n              role: \"listitem\"\n            }}\n            key={index}\n            index={index}\n            style={{\n              position: \"absolute\",\n              left: 0,\n              transform: `translateY(${bounds.scrollOffset}px)`,\n              // In case of dynamic row heights, don't specify a height style\n              // otherwise a default/estimated height would mask the actual height\n              height: isDynamicRowHeight ? undefined : bounds.size,\n              width: \"100%\"\n            }}\n          />\n        );\n      }\n    }\n    return children;\n  }, [\n    RowComponent,\n    getCellBounds,\n    isDynamicRowHeight,\n    rowCount,\n    rowProps,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedSize(),\n        width: \"100%\",\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      role: \"list\",\n      ...rest,\n      className,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        maxHeight: \"100%\",\n        flexGrow: 1,\n        overflowY: \"auto\",\n        ...style\n      }\n    },\n    rows,\n    children,\n    sizingElement\n  );\n}\n", "import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { assert } from \"../../utils/assert\";\nimport { DATA_ATTRIBUTE_LIST_INDEX } from \"./List\";\nimport type { DynamicRowHeight } from \"./types\";\n\nexport function useDynamicRowHeight({\n  defaultRowHeight,\n  key\n}: {\n  defaultRowHeight: number;\n  key?: string | number;\n}) {\n  const [state, setState] = useState<{\n    key: string | number | undefined;\n    map: Map<number, number>;\n  }>({\n    key,\n    map: new Map()\n  });\n\n  if (state.key !== key) {\n    setState({\n      key,\n      map: new Map()\n    });\n  }\n\n  const { map } = state;\n\n  const getAverageRowHeight = useCallback(() => {\n    let totalHeight = 0;\n\n    map.forEach((height) => {\n      totalHeight += height;\n    });\n\n    if (totalHeight === 0) {\n      return defaultRowHeight;\n    }\n\n    return totalHeight / map.size;\n  }, [defaultRowHeight, map]);\n\n  const getRowHeight = useCallback(\n    (index: number) => {\n      const measuredHeight = map.get(index);\n      if (measuredHeight !== undefined) {\n        return measuredHeight;\n      }\n\n      // Temporarily store default height in the cache map to avoid scroll jumps if rowProps change\n      // Else rowProps changes can impact the average height, and cause rows to shift up or down within the list\n      // see github.com/bvaughn/react-window/issues/863\n      map.set(index, defaultRowHeight);\n\n      return defaultRowHeight;\n    },\n    [defaultRowHeight, map]\n  );\n\n  const setRowHeight = useCallback((index: number, size: number) => {\n    setState((prevState) => {\n      if (prevState.map.get(index) === size) {\n        return prevState;\n      }\n\n      const clonedMap = new Map(prevState.map);\n      clonedMap.set(index, size);\n\n      return {\n        ...prevState,\n        map: clonedMap\n      };\n    });\n  }, []);\n\n  const resizeObserverCallback = useStableCallback(\n    (entries: ResizeObserverEntry[]) => {\n      if (entries.length === 0) {\n        return;\n      }\n\n      entries.forEach((entry) => {\n        const { borderBoxSize, target } = entry;\n\n        const attribute = target.getAttribute(DATA_ATTRIBUTE_LIST_INDEX);\n        assert(\n          attribute !== null,\n          `Invalid ${DATA_ATTRIBUTE_LIST_INDEX} attribute value`\n        );\n\n        const index = parseInt(attribute);\n\n        const { blockSize: height } = borderBoxSize[0];\n        if (!height) {\n          // Ignore heights that have not yet been measured (e.g. <img> elements that have not yet loaded)\n          return;\n        }\n\n        setRowHeight(index, height);\n      });\n    }\n  );\n\n  const [resizeObserver] = useState(\n    () => new ResizeObserver(resizeObserverCallback)\n  );\n\n  useEffect(() => {\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [resizeObserver]);\n\n  const observeRowElements = useCallback(\n    (elements: Element[] | NodeListOf<Element>) => {\n      elements.forEach((element) => resizeObserver.observe(element));\n      return () => {\n        elements.forEach((element) => resizeObserver.unobserve(element));\n      };\n    },\n    [resizeObserver]\n  );\n\n  return useMemo<DynamicRowHeight>(\n    () => ({\n      getAverageRowHeight,\n      getRowHeight,\n      setRowHeight,\n      observeRowElements\n    }),\n    [getAverageRowHeight, getRowHeight, setRowHeight, observeRowElements]\n  );\n}\n", "import { useState } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the List component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useListCallbackRef =\n  useState as typeof useState<ListImperativeAPI | null>;\n", "import { useRef } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the List component.\n */\nexport const useListRef = useRef as typeof useRef<ListImperativeAPI>;\n", "let size: number = -1;\n\nexport function getScrollbarSize(recalculate: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement(\"div\");\n    const style = div.style;\n    style.width = \"50px\";\n    style.height = \"50px\";\n    style.overflow = \"scroll\";\n\n    document.body.appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nexport function setScrollbarSizeForTests(value: number) {\n  size = value;\n}\n"],
  "mappings": "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",
  "names": ["isRtl", "element", "currentElement", "useIsRtl", "dir", "value", "setValue", "useState", "useLayoutEffect", "useIsomorphicLayoutEffect", "useEffect", "parseNumericStyleValue", "useResizeObserver", "box", "defaultHeight", "defaultWidth", "disabledProp", "mode", "style", "styleHeight", "styleWidth", "useMemo", "state", "setState", "disabled", "resizeObserver", "entries", "entry", "contentRect", "target", "prevState", "useStableCallback", "fn", "ref", "useRef", "useCallback", "args", "cachedRTLResult", "getRTLOffsetType", "recalculate", "outerDiv", "outerStyle", "innerDiv", "innerStyle", "adjustScrollOffsetForRtl", "containerElement", "direction", "scrollOffset", "clientWidth", "scrollLeft", "scrollWidth", "assert", "expectedCondition", "message", "shallowCompare", "a", "b", "key", "getEstimatedSize", "cachedBounds", "itemCount", "itemSize", "bounds", "averageItemSize", "getOffsetForIndex", "align", "index", "containerScrollOffset", "containerSize", "estimatedTotalSize", "maxOffset", "minOffset", "getStartStopIndices", "overscanCount", "maxIndex", "startIndexVisible", "stopIndexVisible", "startIndexOverscan", "stopIndexOverscan", "currentIndex", "createCachedBounds", "itemProps", "cache", "size", "previousRowBounds", "useCachedBounds", "useItemSize", "itemSizeProp", "useVirtualizer", "containerStyle", "defaultContainerSize", "onResize", "indices", "setIndices", "height", "width", "prevSizeRef", "prevSize", "getCellBounds", "getEstimatedSizeUtil", "getStartStopIndicesUtil", "onScroll", "prev", "scrollTop", "next", "scrollToIndex", "useMemoizedObject", "unstableObject", "arePropsEqual", "prevProps", "nextProps", "prevAriaAttributes", "prevStyle", "prevRest", "nextAriaAttributes", "nextStyle", "nextRest", "Grid", "CellComponentProp", "cellPropsUnstable", "children", "className", "columnCount", "columnWidth", "gridRef", "onCellsRendered", "rowCount", "rowHeight", "tagName", "rest", "cellProps", "CellComponent", "memo", "setElement", "getColumnBounds", "getEstimatedWidth", "columnStartIndexOverscan", "columnStartIndexVisible", "scrollToColumnIndex", "columnStopIndexOverscan", "columnStopIndexVisible", "getRowBounds", "getEstimatedHeight", "rowStartIndexOverscan", "rowStartIndexVisible", "scrollToRowIndex", "rowStopIndexOverscan", "rowStopIndexVisible", "useImperativeHandle", "behavior", "columnAlign", "columnIndex", "rowAlign", "rowIndex", "left", "top", "cells", "rowBounds", "columns", "columnBounds", "createElement", "jsx", "sizingElement", "useGridCallbackRef", "useGridRef", "isDynamicRowHeight", "DATA_ATTRIBUTE_LIST_INDEX", "List", "listRef", "onRowsRendered", "RowComponentProp", "rowHeightProp", "rowPropsUnstable", "rowProps", "RowComponent", "isDynamicRowHeightUtil", "rows", "item", "attribute", "useDynamicRowHeight", "defaultRowHeight", "map", "getAverageRowHeight", "totalHeight", "getRowHeight", "measuredHeight", "setRowHeight", "clonedMap", "resizeObserverCallback", "borderBoxSize", "observeRowElements", "elements", "useListCallbackRef", "useListRef", "getScrollbarSize", "div"]
}
